
* Определение функции
def ИМЯ_ФУНКЦИИ(параметры):
	выражение № 1
	выражение № 2
	...

Возможно задание значения параметров по умолчанию:
def func(a, b='asd', c=0):
	
* Список: L = [1,2,3]
Отсчет с 0 индекса
Создание копии списка: L2 = L1[:] или L2 = list(L1)
Создание ссылки (не копии): L2 = L1

* Итерация по списку:
простая итерация списка: for x in L:
сортированная итерация:	for x in sorted(L):
уникальная итерация: for x in set(L):
итерация в обратном порядке: for x in reversed(L):
исключающая итерация — например, вывести элементы 1-го списка, которых нет во 2-м списке: for item in set(L).difference(L2)

* Генерация списков
статическая форма: L = [1,2,3]
конструктор списков (list comprehension):
 цикл внутри квадратных скобок: a = [ i*i for i in range(1,10)]
 условный конструктор: a = [ i*i for i in range(1,10) if i % 2 == 0]

Операция Sequence unpacking — присваивание списку переменных списка значений: a, b = [1,2]

* Списки имеют большой набор функций:
append - добавление эл-та в конец
extend — добавление последовательность эл-тов в конец
insert — вставка
index — найти индекс первого вхождения конкретного элемента
count — подсчет повторов элемента
remove - удаление конкретного эл-та (нельзя совмещать с итерацией)
del — удаление эл-та по индексу (нельзя совмещать с итерацией)
sort — сортировка
reverse — реверс
pop() — извлечение последнего добавленного эл-та (для использования списка как стек, FILO)
pop(0) - извлечение эл-тов в том порядке, в котором добавлялись (для использования списка как очередь, FIFO)
len — длина списка
max — максимальный элемент
min — минимальный элемент
оператор in — проверка элемента на вхождение

* Кортеж (tuple) = неизменяемый список
L = (1,2,3) или вообще без скобок: L = 1,2,3
L = tuple('mama') - tuple() превращает строку в кортеж

* Сет — неотсортированная коллекция уникальных элементов; индексы и срезы не поддерживаются
s = set('abcde')
можно выполнять вычитание (s1 - s2), сложение (s1 | s2), пересечение (s1 & s2)
у сета есть встроенные ф-ции:
add() — добавление элемента: s.add(6)
remove() — удаление элемента: s.remove('a')
итерация - for item in s:print (item)

* Встроенные ф-ции последовательностей
filter(function, sequence) - озвращает последовательность, состоящую из тех элементов последовательности sequence, для которых function(item) является истиной
Пример: определим простые числа в диапазоне до 100:
def f(x):
     for y in xrange(2, x):
         if x%y==0: return 0
     return 1
print filter(f, xrange(2, 100))
>>> [2, 3, 5, 7, 11, 13, 17, 19, 23, ... , 59, 61, 67, 71, 73, 79, 83, 89, 97]

map(function, sequence) возвращает список значений, полученных применением функции function к элементам одной или нескольких последовательностей
Пример 1: создадим список кубов натуральных чисел от 1 до 10:
def cube(x): return x*x*x
print map(cube, xrange(1, 11))

Пример 2: можно перебирать элементы одновременно нескольких последовательностей одной длины:
seq1 = [1,2,3]
seq2 = [11,12,13]
for x, y in map(None, seq1, seq2):
    print x, y
>>> 1 11
>>> 2 12
>>> 3 13

zip(sequence) — функция, аналогичная map() в последнем варианте, но может работать с последовательностями разной длины, возвращает список кортежей:
>>> a = (1, 2, 3, 4)
>>> b = (5, 6, 7, 8)
>>> zip(a, b)
[(1, 5), (2, 6), (3, 7), (4, 8)]

reduce(function, sequence) возвращает значение, полученное путем последовательного применения бинарной функции function сначала к первым двум элементам последовательности sequence, затем к результату и следующему элементу и т. д. Например, вычислим сумму арифметической последовательности:

>>> def add(x, y): return x+y
...
>>> reduce(add, xrange(1, 11))
55

* Словарь (dictionary) — это ассоциативный массив или хеш. Это неупорядоченное множество пар ключ: значение с требованием уникальности ключей. Пара фигурных скобок {} создает пустой словарь
В отличие от последовательностей, доступ к эл-там словаря производится по ключу, а не по индексу, ключ может быть любого типа и не допускает изменений
Операции над словарем — сохранение с заданным ключом, извлечение по ключу значения, удаление пары key:value с помощью инструкции del()
Список ключей (в произвольном порядке) - метод keys(); для сортировки списка нужно применить метод sort()
Определение наличия определенного ключа - метод has_key(), в версии 3.0 — оператор in
При добавлении нового объекта в словарь, если ранее ключу уже соответствовало некоторое значение, оно будет перезаписано

Способы создания словаря:
Обычное выражение: D = {'name': 'mel', 'age': 45}

Динамический вариант:
	D = {}
	D['name'] = 'mel'
	D['age'] = 45

С помощью функции dict() — ключи при этом должны быть строками. С помощью этой функции можно избавить себя от обязательного условия заключать ключ в кавычки
В примере приведены четыре варианта создания одного и того же словаря:
    d1 = dict(id=1948, name="Washer", size=3)
    d2 = dict({"id": 1948, "name": "Washer", "size": 3})
    d3 = dict([("id", 1948), ("name", "Washer"), ("size", 3)])
    d4 = dict(zip(("id", "name", "size"), (1948, "Washer", 3)))

С помощью fromkeys() — создает словарь по списку ключей с пустыми значениями:
    D = {}.fromkeys(['name', 'age'],123)

С помощью конструктора:
	d = dict((x, x**2) for x in xrange(5))

* Функции/методы словаря
dict() — создание словаря;
len() — возвращает число пар;
clear() — удаляет все значения из словаря;
copy() — создает псевдокопию словаря;
deepcopy() — создает полную копию словаря;
fromkeys() — создает словарь по заданным ключам с пустыми значениями
	{}.fromkeys(['name', 'age'])
	{}.fromkeys(['name', 'age'], 123) - с значениями по умолчанию
get() — получает значение по ключу, в случае отсутствия дает None;
has_key() — проверка значения по ключу;
items() — возвращает список значений;
iteriyems() — возвращает итератор;
keys() — возвращает список ключей;
iterkeys() — возвращает итератор ключей;
pop() — извлекает значение по ключу с последующим удалением;
popitem() — извлекает произвольное значение с последующим удалением;
update() — изменяет значение по ключу
	d2 = {'www':'python.org'}
	d.update(d2)
values() — возвращает список значений;
itervalues() — возвращает итератор на список значений.
in — оператор, проверяет наличие значения по ключу;
del — оператор, удаляет пару по ключу;
dict() — конструирует словарь с помощью последовательности.

Т.к. словари есть map, а не последовательности, к ним нельзя применить конкатенацию или срезы
К словарям можно применять стандартные операторы сравнения: <, <=, ==, !=, >=, >
Можно проходить по ключам словаря, используя for


* Модули
Модуль — пространство имен, — namespace, и все имена внутри модуля (функции и переменные) называются атрибутами
Импорт модулей можно выполнить несколькими способами:
	import my_module
	my_module.func1()
	my_module.func2()

Более короткая запись при помощи локальной переменной: f1 = my_module.func1

Взятие непосредственно имени без имени модуля:
	from my_module import func1, func2  (импорт на основе from обладает такой особенностью, что он делает импортируемые атрибуты read-only)
	func1()
	func1 = 42 — локальная переменная, а переменные func1, func2 в самом модуле my_module не меняются

	import small
	small.x = 42 - глобальная переменная

Во избежание недоразумений import предпочтительнее без from в тех случаях, когда один и тот же модуль используется в нескольких местах
	
Включение всех имен, определенных в модуле:
	from my_module import *
	func1()
в корневом __init__.py может быть определен список __all__ , в котором перечисляются модули, которые импортируются в этом случае. Например: __all__ = ["Server", "Client"]
Импорт всех имен может привести к конфликтам. При этом глобальные переменные становятся доступными только на чтение — вместо них будут созданы локальные

Для предотвращения конфликта имен можно использовать создание алиаса: from my_module import open as my_open

Поскольку модуль загружается один раз, для его повторной загрузки можно использовать функцию reload()
Каждый модуль имеет собственное пространство имен, являющееся глобальной областью видимости для всех определенных в нем функций
Для того чтобы переменные этого модуля не попали в конфликт с другими глобальными именами или другими модулями, нужно использовать префикс: _имя_модуля_._имя_переменной_

Модули могут импортировать другие модули. Обычно инструкцию import располагают в начале модуля или программы

Для выяснения имен, определенных в модуле, можно использовать встроенную функцию dir(имя_модуля)

Использование модулей позволяет избежать конфликта имен
Файл _init_.py необходим для того, чтобы интерпретатор распознал каталог, как содержащий пакет. Обычно это пустой файл

* Классы
Поле и метод класса = аттрибут данных и аттрибут-метод класса
Определение класса:
class Sample:
 field1 = 15 	- аттрибут данных
 __field2 = 12 	- приватный аттрибут данных (слева - 2 подчеркивания)
 def __init__(self,n): - конструктор по умолчанию (первый параметр должен быть self - аналог "this" в С++, полезен для обращения к другим аттрибутам класса)
  self.n = n 	- аттрибут данных n в этом случае объявлять не надо
 def func(m): 	- аттрибут-метод
  self.m = m

Создание инстанса (экземпляра) класса: s = Sample()

Методы необязательно определять внутри тела класса:
def method_for_simple(self, x, y):
 return x + y
class Simple:
 f = method_for_simple

Определение производного класса:					class Derived(Base):
Если базовый класс определен не в текущем модуле:	class Derived(module_name.Base):
Вызвать метод базового класса можно с префиксом: Base.method()

Cуществует ограниченная поддержка множественного наследования: class Derived(Base1,Base2,Base3):
Поиск атрибута производится в следующем порядке:
    в Derived
    в Base1, затем рекурсивно в базовых классах Base1
    в Base2, затем рекурсивно в базовых классах Base2
    и т.д.

Ф-ция __str__ есть в каждом классе, выводит его содержимое, вызывается, когда распечатывается инстанс класса. Может быть переопределена

Объект-класс создается с помощью определения класса. Объекты-классы имеют следующие атрибуты:
__name__ — имя класса
__module__ — имя модуля
__dict__ — словарь атрибутов класса, можно изменять этот словарь напрямую
__bases__ — кортеж базовых классов в порядке их следования
__doc__ — строка документации класса

Экземпляр (инстанс) класса возвращается при вызове объекта-класса. Объект у класса может быть один, экземпляров (или инстансов) — несколько. Экземпляры имеют следующие атрибуты:
__dict__ — словарь атрибутов класса, можно изменять этот словарь напрямую;
__class__ — объект-класс, экземпляром которого является данный инстанс;
__init__ — конструктор. Если в базовом классе есть конструктор, конструктор производного класса должен вызвать его;
__del__ — деструктор. Если в базовом классе есть деструкор, деструктор производного класса должен вызвать его;
__cmp__ — вызывается для всех операций сравнения;
__hash__ — возвращает хеш-значение объекта, равное 32-битному числу;
__getattr__ — возвращает атрибут, недоступный обычным способом;
__setattr__ — присваивает значение атрибуту;
__delattr__ — удаляет атрибут;
__call__ — срабатывает при вызове экземпляра класса

Для эмуляции последовательностей в экземплярах классов есть встроенные методы:
__len__ — возвращает длину последовательности;
__getitem__ — получение элемента по индексу или ключу;
__setitem__ — присваивание элемента с данным ключом или индексом;
__delitem__ — удаление элемента с данным ключом или индексом;
__getslice__ — возвращает вложенную последовательность;
__setslice__ — заменяет вложенную последовательность;
__delslice__ — удаляет вложенную последовательность;
__contains__ — реализует оператор in

Объекты классов можно привести к строковому или числовому типу:
__repr__ — возвращает формальное строковое представление объекта;
__str__ — возвращает строковое представление объекта;
__oct__ , __hex__ , __complex__ , __int__ , __long__ , __float__ — возвращают строковое представление в соответствующей системе счисления

* Bound и unbound методы
Прямой вызов конструктора базового класса из перегруженного конструктора без создания инстанса базового класса (считается устаревшим методом) - такой базовый конструктор относится к категории unbound-методов, в противоположность методам, которые вызываются для инстансов классов и называются bound-методами
class Barsik(Cat):
  def __init__(self):
      Cat.__init__(self)            
      self.sound = 'Aaaammm!'
      print self.sound

В начале программы нужно определить метакласс, который указывает на то, что класс реализован в так называемом новом стиле — new-style. Затем нужно вызвать стандартный метод super для базового конструктора (в качестве первого параметра ему нужно передать инстанс класса):
__metaclass__ = type
...
class Barsik(Cat):
    def __init__(self):
      super(Barsik, self).__init__()
      self.sound = 'Aaaammm!'
      print self.sound

Статический метод — функция, определенная вне класса и не имеющая атрибута self:
class Spam:
    numInstances = 0
    def __init__(self):
        Spam.numInstances = Spam.numInstances + 1
    
def printNumInstances():
    print "Number of instances created: ", Spam.numInstances

* Статический метод может быть определен и внутри класса — для этого используется ключевое слово staticmethod, причем метод может быть вызван как статически, так и через инстанс:
class Multi:
    def imeth(self, x):
        print self, x
    def smeth(x):
        print x
    def cmeth(cls, x):
        print cls, x
    smeth = staticmethod(smeth)
    cmeth = classmethod(cmeth)
     
>>> Multi.smeth(3)    
3
>>> obj=Multi()
>>> obj.smeth(5)
5

Методы класса определяются с помощью ключевого слова classmethod — здесь автоматически питон передает в качестве первого параметра сам класс (cls):
>>> Multi.cmeth(7)
__main__.Multi 7
>>> obj.cmeth(10)
__main__.Multi 10 

* Итератор
Для использования класса как итератора в нем нужно определить два стандартных метода — __iter__ и next

class Reverse:
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> for char in Reverse('12345'): print char
5
4
3
2
1

Итератор можно сконвертировать в список:
>>> rvr = list(Reverse('12345'))
>>> rvr
['5', '4', '3', '2', '1']

* Property — атрибут класса, возвращаемый через стандартную функцию property, которая в качестве аргументов принимает другие функции класса:
class DateOffset:
    def __init__(self):
        self.start = 0
    
    def _get_offset(self):
        self.start +=  5
        return self.start 

    offset = property(_get_offset)

>>> d = DateOffset()
>>> d.offset
5
>>> d.offset
10

* Слоты — это список атрибутов, задаваемый в заголовке класса с помощью __slots__. В инстансе необходимо назначить атрибут, прежде чем пользоваться им:
class limiter(object):
    __slots__ = ['age', 'name', 'job']
    
>>> x=limiter()    
>>> x.age = 20

* Функтор — это класс, имеющий метод __call__ — при этом объект можно вызвать как функцию

* Дескриптор — это класс, который хранит и контролирует атрибуты других классов. Вообще любой класс, который имплементирует один из специальных методов — __get__ , __set__ , __delete__, является дескриптором.
Класс в этом случае не имеет собственных аттрибутов, но обращается к ним так, как будто они есть, - на самом деле они хранятся в дескрипторе

* Последовательность - класс, в котором реализованы методы __getitem__, __setitem__. Но нельзя применять стандартные методы __del__ , __len__.
class MySequence:
  def __init__(self, start=0, step=1):
      self.start = start
      self.step = step
      self.changed = {}
  def __getitem__(self, key):
      return self.start + key*self.step
  def __setitem__(self, key, value):
      self.changed[key] = value    

* Работа с файлами
Для открытия файла: open(name[, mode[, buffering]])
Функция возвращает файловый объект. Обязателен только первый аргумент. Если остальные параметры отсутствуют, файл будет доступен на чтение.
Таблица режимов (mode) функции open:
'r' – чтение
'w' – запись
'a' – добавление
'b' – бинарный режим
'+' – чтение/запись

Режим '+' может быть добавлен к остальным режимам. По умолчанию питон открывает файлы в текстовом режиме. Для открытия файла в бинарном режиме на чтение можно добавить 'rb'. Третий параметр устанавливает размер буферизации при работе с файлом. По умолчанию он выключен, и чтение/запись идет напрямую с диска на диск. Для включения буфера третий параметр должен быть отличным от нуля.

Чтение из файла:
>>> f = open('my_file', 'r')
>>> f.read(5)
'Hello'
>>> f.read()
', World!'
>>> f.close()

Запись в файл: f.write('Hello, World!')

В Python многие объекты являются файлами: стандартный ввод sys.stdin, стандартный вывод sys.stdout, объекты, открываемые функцией urllib.urlopen и т.д.
Построчное чтение/запись: f.readline(), f.writeline()
Чтение/запись всех строк: readlines(), writelines()

"Сериализация" объектов (объект будет сохранен на диске, потом прочитан):
import pickle
t1 = [1, 2, 3]
s = pickle.dumps(t1)
t2 = pickle.loads(s)
print t2
[1, 2, 3]
Есть нюанс: t1 и t2 будут двумя разными объектами, хотя и идентичными

--------------------------------------------------------------------------------------------
* Бинарные файлы
Можно упаковывать объекты в структуры С в виде строк в бинарном формате и обратно:
pack(format, value1, value2 ...)
unpack(format, string)
calcsize(format)
 где format - строка формата; содержит кол-во и тип упаковывваемых значений

Таблица основных форматов:
================================================
Format      C Type          Python 	
================================================
c           char         	string of length 1 	 
?           Bool            bool 	
i 	   		int             integer 	 
l 	   		long            integer 	 
f 	   		float           float 	 
d 	   		double          float 	 
s 	   		char[]          string 	 

from struct import *
out = open("123.bin", "wb")    
format = "if5s"                
data = pack(format, 24,12.48,'12345')
out.write(data)
out.close()
input = open("123.bin", "rb")
data = input.read()
input.close()
format = "if5s"                   			# one integer
value,value2,value3 = unpack(format, data)	# note the ',' in 'value,': unpack apparently returns a n-uple
print value
print value2
print value3
print calcsize(format)

>>> 24
>>> 12.4799995422
>>> 12345
>>> 13

--------------------------------------------------------------------------------------------
* Работа с файловой системой
Стандартный модуль os имеет интерфейс работы с файловой системой
Текущий каталог: os.getcwd
Проверить наличие файла в текущем каталоге: os.path.exists('my_file')
Вывести список файлов и подкаталогов для данного каталога: os.listdir(path)
"Склеиваем" путь к директории и имя файла/директории: os.path.join(dir, name)
Проверка, файл ли это: os.path.isfile(path)
Функция os.path.walk вызывает переданную функцию-параметр, имеет 3 параметра: каталог, пользовательская функция, список для подсчета
'.' - текущий каталог

--------------------------------------------------------------------------------------------
* Boolean in Python: True, False

При возникновении Indentation Error: включить показ непечатных символов, исправить где нужно пробелы на табы (или наоборот)

Удаление пробелов с обоих сторон строки: s = s.strip()
Справа/слева: s = s.rstrip(), s = s.lstrip()
Можно удалять и другие символы: s = s.strip(' \t\n\r')
Длина строки: s.__len__()
Increment: not ++, but +=1
--------------------------------------------------------------------------------------------

* Installation of pip
https://stackoverflow.com/questions/32639074/why-am-i-getting-importerror-no-module-named-pip-right-after-installing-pip
"After running get_pip.py with python embed you have to modify your pythonXX._pth file. Add Lib\site-packages"
